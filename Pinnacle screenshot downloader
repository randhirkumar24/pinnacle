// ==UserScript==
// @name         Screenshot & PDF Current Section (PDF Viewer Only)
// @namespace    http://tampermonkey.net/
// @version      2.6
// @description  Scrolls the PDF viewer, screenshots only the viewer, and merges into a PDF with 3 images per page without visible lines
// @match        *://ebooks.ssccglpinnacle.com/*
// @grant        none
// @run-at       document-end
// ==/UserScript==

(function() {
    function loadLibs(callback) {
        let loaded = 0;
        const timeout = setTimeout(() => {
            if (loaded < 2) {
                alert('Failed to load required libraries. Please try again.');
            }
        }, 10000);

        function check() {
            if (++loaded === 2) {
                clearTimeout(timeout);
                callback();
            }
        }

        if (!window.html2canvas) {
            const s1 = document.createElement('script');
            s1.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            s1.onload = check;
            s1.onerror = () => {
                clearTimeout(timeout);
                alert('Failed to load html2canvas library.');
            };
            document.body.appendChild(s1);
        } else check();

        if (!window.jspdf) {
            const s2 = document.createElement('script');
            s2.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            s2.onload = check;
            s2.onerror = () => {
                clearTimeout(timeout);
                alert('Failed to load jsPDF library.');
            };
            document.body.appendChild(s2);
        } else check();
    }

    function findContentViewer() {
        const el = document.querySelector('[data-testid="core__inner-pages"]') ||
                   document.querySelector('.rpv-core__inner-pages');
        if (el) return el;

        // Fallback: pick the tallest scrollable div
        const candidates = Array.from(document.querySelectorAll('div'));
        let best = null;
        let maxScrollHeight = 0;
        for (const e of candidates) {
            if (e.scrollHeight > e.clientHeight + 50 && e.clientWidth > 400) {
                if (e.scrollHeight > maxScrollHeight) {
                    maxScrollHeight = e.scrollHeight;
                    best = e;
                }
            }
        }
        return best || document.scrollingElement;
    }

    function takeScreenshot(viewer) {
        return html2canvas(viewer, {
            useCORS: true,
            allowTaint: true,
            scrollX: 0,
            scrollY: 0,
            width: viewer.clientWidth,
            height: viewer.clientHeight,
            windowWidth: viewer.clientWidth,
            windowHeight: viewer.clientHeight,
            scale: 1,
            logging: false
        });
    }

    // Function to merge multiple canvas elements vertically without visible lines
    function mergeCanvasVertically(canvases) {
        if (canvases.length === 0) return null;
        if (canvases.length === 1) return canvases[0];

        const width = canvases[0].width;

        // Calculate total height without gaps
        let totalHeight = 0;
        for (let i = 0; i < canvases.length; i++) {
            totalHeight += canvases[i].height;
        }

        const mergedCanvas = document.createElement('canvas');
        mergedCanvas.width = width;
        mergedCanvas.height = totalHeight;
        const ctx = mergedCanvas.getContext('2d');

        let currentY = 0;

        // Draw each canvas seamlessly
        for (let i = 0; i < canvases.length; i++) {
            ctx.drawImage(
                canvases[i],
                0, 0, // Start from the top of the source canvas
                width, canvases[i].height, // Use full height of source
                0, currentY, // Position in destination
                width, canvases[i].height // Use full height in destination
            );
            currentY += canvases[i].height;
        }

        return mergedCanvas;
    }

    async function scrollAndCapturePDF() {
        const viewer = findContentViewer();
        if (!viewer) {
            alert('Content viewer not found! Please make sure you are on a page with scrollable content.');
            return;
        }

        if (!window.html2canvas || !window.jspdf || !window.jspdf.jsPDF) {
            alert('Required libraries (html2canvas or jsPDF) failed to load. Please try again.');
            return;
        }

        console.log('Found viewer:', viewer);
        console.log('Viewer dimensions - Width:', viewer.clientWidth, 'Height:', viewer.clientHeight);
        console.log('Scroll dimensions - ScrollHeight:', viewer.scrollHeight, 'ScrollWidth:', viewer.scrollWidth);

        const originalScroll = viewer.scrollTop;
        const viewportHeight = viewer.clientHeight; // Visible height without scrolling
        const totalHeight = viewer.scrollHeight; // Total scrollable height

        // Calculate page height and number of pages
        let totalPages = 3; // Default assumption, but let's try to detect

        // Try to find page indicators in the DOM
        const pageElements = viewer.querySelectorAll('[data-page-number], .rpv-core__page, [class*="page"]');
        if (pageElements.length > 0) {
            totalPages = pageElements.length;
        } else {
            // If no page elements found, estimate based on common ratios
            totalPages = Math.round(totalHeight / (viewportHeight * 2.7)); // Rough estimate
            if (totalPages < 1) totalPages = 1;
        }

        const pageHeight = totalHeight / totalPages;
        console.log(`Total pages detected: ${totalPages}`);
        console.log(`Page height: ${pageHeight}px, Viewport height: ${viewportHeight}px`);

        const progressDiv = document.createElement('div');
        progressDiv.style.position = 'fixed';
        progressDiv.style.top = '50%';
        progressDiv.style.left = '50%';
        progressDiv.style.transform = 'translate(-50%, -50%)';
        progressDiv.style.background = 'rgba(0,0,0,0.8)';
        progressDiv.style.color = 'white';
        progressDiv.style.padding = '20px';
        progressDiv.style.borderRadius = '10px';
        progressDiv.style.zIndex = '999999';
        progressDiv.style.fontSize = '16px';
        progressDiv.innerText = 'Capturing screenshots... 0%';
        document.body.appendChild(progressDiv);

        try {
            const pageCanvases = [];

            // Process each page
            for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {
                const pageStartPosition = pageIndex * pageHeight;
                const pageEndPosition = Math.min((pageIndex + 1) * pageHeight, totalHeight);
                const actualPageHeight = pageEndPosition - pageStartPosition;

                console.log(`Processing page ${pageIndex + 1}: ${pageStartPosition} to ${pageEndPosition} (height: ${actualPageHeight}px)`);

                const pageChunks = [];
                let currentPosition = pageStartPosition;

                // Capture chunks for this page with overlap
                const overlapPixels = 50; // Overlap between consecutive screenshots
                let chunkIndex = 0;

                while (currentPosition < pageEndPosition) {
                    const remainingHeight = pageEndPosition - currentPosition;
                    const isLastChunk = (currentPosition + viewportHeight) >= pageEndPosition;

                    // For the last chunk, we need to capture the exact remaining height
                    const chunkHeight = isLastChunk ? remainingHeight : viewportHeight;

                    console.log(`  Capturing chunk ${chunkIndex + 1} at position ${currentPosition} (chunk height: ${chunkHeight}px)`);

                    viewer.scrollTop = currentPosition;
                    await new Promise(resolve => setTimeout(resolve, 1200)); // Wait for scroll

                    const canvas = await takeScreenshot(viewer);

                    // If this is the last chunk and it's smaller than viewport, crop it
                    if (isLastChunk && chunkHeight < viewportHeight) {
                        const croppedCanvas = document.createElement('canvas');
                        croppedCanvas.width = canvas.width;
                        croppedCanvas.height = (chunkHeight / viewportHeight) * canvas.height;
                        const ctx = croppedCanvas.getContext('2d');
                        ctx.drawImage(canvas, 0, 0, canvas.width, croppedCanvas.height, 0, 0, canvas.width, croppedCanvas.height);
                        pageChunks.push(croppedCanvas);
                    } else {
                        pageChunks.push(canvas);
                    }

                    // Move to next position with overlap (except for last chunk)
                    if (isLastChunk) {
                        break;
                    } else {
                        currentPosition += viewportHeight - overlapPixels;
                    }

                    chunkIndex++;

                    const overallProgress = Math.round(((pageIndex * pageHeight + (currentPosition - pageStartPosition)) / totalHeight) * 100);
                    progressDiv.innerText = `Page ${pageIndex + 1}/${totalPages} - Capturing chunks... ${overallProgress}%`;
                }

                // Merge all chunks for this page
                const mergedPageCanvas = mergeCanvasVertically(pageChunks);
                pageCanvases.push(mergedPageCanvas);

                console.log(`Completed page ${pageIndex + 1} with ${pageChunks.length} chunks`);
            }

            viewer.scrollTop = originalScroll;
            progressDiv.innerText = `Generating PDF...`;

            const { jsPDF } = window.jspdf;

            // Use A4 dimensions
            const a4Width = 595.28; // A4 width in points
            const a4Height = 841.89; // A4 height in points

            const pdf = new jsPDF({
                orientation: "portrait",
                unit: "pt",
                format: [a4Width, a4Height]
            });

            // Group canvases into sets of 3 for each PDF page
            const imagesPerPage = 3;
            for (let i = 0; i < pageCanvases.length; i += imagesPerPage) {
                const group = pageCanvases.slice(i, i + imagesPerPage);
                const mergedCanvas = mergeCanvasVertically(group);

                if (mergedCanvas) {
                    const imgData = mergedCanvas.toDataURL('image/png');

                    // Calculate dimensions to fit the image within A4 while maintaining aspect ratio
                    const canvasAspectRatio = mergedCanvas.width / mergedCanvas.height;
                    const a4AspectRatio = a4Width / a4Height;

                    let imgWidth, imgHeight;

                    if (canvasAspectRatio > a4AspectRatio) {
                        // Image is wider than A4 ratio, fit to width
                        imgWidth = a4Width;
                        imgHeight = a4Width / canvasAspectRatio;
                    } else {
                        // Image is taller than A4 ratio, fit to height
                        imgHeight = a4Height;
                        imgWidth = a4Height * canvasAspectRatio;
                    }

                    // Center the image on the page
                    const x = (a4Width - imgWidth) / 2;
                    const y = (a4Height - imgHeight) / 2;

                    pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);

                    // Add new page if there are more canvases to process
                    if (i + imagesPerPage < pageCanvases.length) {
                        pdf.addPage();
                    }

                    console.log(`Added PDF page with ${Math.min(imagesPerPage, group.length)} images (indices ${i} to ${i + group.length - 1})`);
                }
            }

            const sectionName = document.querySelector('.Sidebar_chapterTitle__mOVtZ.Sidebar_active__2relq')?.innerText
                || document.querySelector('.Sidebar_chapterTitle__mOVtZ')?.innerText
                || document.querySelector('[class*="chapter"][class*="active"]')?.innerText
                || document.querySelector('[class*="active"][class*="title"]')?.innerText
                || document.querySelector('h1')?.innerText
                || document.querySelector('h2')?.innerText
                || document.title
                || 'section';

            const cleanSectionName = sectionName.replace(/[^\w\s-]/g, '').replace(/\s+/g, '_');
            pdf.save(`${cleanSectionName}.pdf`);

            progressDiv.innerText = 'PDF generated successfully!';
            setTimeout(() => {
                document.body.removeChild(progressDiv);
                alert(`PDF downloaded successfully! ${pageCanvases.length} pages merged into ${Math.ceil(pageCanvases.length / imagesPerPage)} PDF pages.`);
            }, 1000);

        } catch (error) {
            console.error('Error generating PDF:', error);
            document.body.removeChild(progressDiv);
            alert(`Error generating PDF: ${error.message}. Please try again.`);
        }
    }

    function addButton() {
        const existingBtn = document.getElementById('screenshotCurrentSectionBtn');
        if (existingBtn) existingBtn.remove();

        const btn = document.createElement('button');
        btn.id = 'screenshotCurrentSectionBtn';
        btn.innerText = "Screenshot & PDF This Section";
        btn.setAttribute('aria-label', 'Capture section as PDF');
        btn.style.cssText = `
            position: fixed;
            top: 100px;
            right: 20px;
            z-index: 99999;
            padding: 10px 18px;
            background: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        `;
        btn.addEventListener('mouseover', () => {
            btn.style.background = '#c0392b';
            btn.style.transform = 'translateY(-2px)';
        });
        btn.addEventListener('mouseout', () => {
            btn.style.background = '#e74c3c';
            btn.style.transform = 'translateY(0)';
        });
        btn.addEventListener('click', () => {
            btn.disabled = true;
            btn.innerText = "Processing...";
            btn.style.background = "#95a5a6";

            loadLibs(() => {
                scrollAndCapturePDF().finally(() => {
                    btn.disabled = false;
                    btn.innerText = "Screenshot & PDF This Section";
                    btn.style.background = "#e74c3c";
                });
            });
        });

        document.body.appendChild(btn);
    }

    function ensureButtonExists() {
        if (!document.getElementById('screenshotCurrentSectionBtn')) {
            addButton();
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', addButton);
    } else {
        addButton();
    }
    setInterval(ensureButtonExists, 5000);
})();