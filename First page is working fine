// ==UserScript==
// @name         Screenshot & PDF Current Section (PDF Viewer Only)
// @namespace    http://tampermonkey.net/
// @version      1.3
// @description  Scrolls the PDF viewer, screenshots only the viewer, and merges into a single PDF
// @match        *://ebooks.ssccglpinnacle.com/*
// @grant        none
// @run-at       document-end
// ==/UserScript==

(function() {
    /**
     * Dynamically loads required external libraries (html2canvas and jsPDF)
     * Uses a callback-based approach to ensure both libraries are loaded before proceeding
     * @param {Function} callback - Function to execute once all libraries are loaded
     */
    function loadLibs(callback) {
        let loaded = 0; // Counter to track how many libraries have been loaded

        // Set a timeout to handle cases where libraries fail to load
        const timeout = setTimeout(() => {
            if (loaded < 2) {
                alert('Failed to load required libraries. Please try again.');
            }
        }, 10000);

        // Helper function to check if both libraries are loaded
        function check() {
            if (++loaded === 2) {
                clearTimeout(timeout);
                callback(); // Execute callback when both libraries are ready
            }
        }

        // Load html2canvas library if not already available
        if (!window.html2canvas) {
            const s1 = document.createElement('script');
            s1.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
            s1.onload = check;
            s1.onerror = () => {
                clearTimeout(timeout);
                alert('Failed to load html2canvas library.');
            };
            document.body.appendChild(s1);
        } else check();

        // Load jsPDF library if not already available
        if (!window.jspdf) {
            const s2 = document.createElement('script');
            s2.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
            s2.onload = check;
            s2.onerror = () => {
                clearTimeout(timeout);
                alert('Failed to load jsPDF library.');
            };
            document.body.appendChild(s2);
        } else check();
    }

    /**
     * Attempts to find the main content viewer/container that contains the scrollable content
     * Uses multiple strategies to locate the correct element:
     * 1. Try specific selectors for known PDF viewers
     * 2. Find the largest scrollable element
     * 3. Fall back to main content areas
     * @returns {Element|null} The content viewer element or null if not found
     */
    function findContentViewer() {
        // Primary selectors - try these first for known PDF viewer structures
        const selectors = [
            '.rpv-core__viewer',           // React PDF Viewer
            '[data-testid*="viewer"]',     // Elements with viewer in test ID
            '[class*="pdf"][class*="viewer"]', // PDF viewer class combinations
            '[class*="content"]',          // Generic content containers
            '[class*="viewer"]',           // Generic viewer containers
            '[class*="main"]',             // Main content areas
            '.main-content',               // Common main content class
            '#main-content',               // Common main content ID
            '[role="main"]',               // Semantic main role
            'main',                        // HTML5 main element
            '.container:not(.sidebar)',    // Containers excluding sidebars
            'div[style*="overflow"]'       // Elements with overflow styles
        ];

        // Try each selector and look for scrollable elements
        for (const selector of selectors) {
            const elements = document.querySelectorAll(selector);
            for (const element of elements) {
                // Check if element is scrollable and has reasonable dimensions
                if (element.scrollHeight > element.clientHeight &&
                    element.clientWidth > 300 &&
                    element.clientHeight > 200 &&
                    !element.classList.contains('sidebar') &&
                    !element.id.includes('sidebar') &&
                    !element.className.includes('sidebar')) {
                    console.log('Found scrollable element:', element, 'Selector:', selector, 'ScrollHeight:', element.scrollHeight, 'ClientHeight:', element.clientHeight);
                    return element;
                }
            }
        }

        // Fallback strategy: Find the largest scrollable element
        const allElements = document.querySelectorAll('div, section, article, main');
        let largestScrollable = null;
        let largestArea = 0;

        for (const element of allElements) {
            if (element.scrollHeight > element.clientHeight) {
                const area = element.clientWidth * element.clientHeight;
                // Select the largest scrollable element that's not a sidebar
                if (area > largestArea &&
                    !element.classList.contains('sidebar') &&
                    !element.id.includes('sidebar') &&
                    !element.className.includes('sidebar')) {
                    largestArea = area;
                    largestScrollable = element;
                }
            }
        }

        // If no scrollable element found, try to find main content areas
        if (!largestScrollable) {
            const mainContentSelectors = [
                '.main',
                '[class*="main"]',
                '.content',
                '[class*="content"]'
            ];

            for (const selector of mainContentSelectors) {
                const elements = document.querySelectorAll(selector);
                for (const element of elements) {
                    // Look for reasonably sized content areas
                    if (element.clientWidth > 500 && element.clientHeight > 300 &&
                        !element.classList.contains('sidebar') &&
                        !element.id.includes('sidebar') &&
                        !element.className.includes('sidebar')) {
                        console.log('Found main content area (not scrollable):', element, 'Selector:', selector);
                        return element;
                    }
                }
            }
        }

        console.log('Selected content viewer:', largestScrollable);
        return largestScrollable;
    }

    /**
     * Captures a screenshot of the specified viewer element using html2canvas
     * @param {Element} viewer - The DOM element to capture
     * @returns {Promise<HTMLCanvasElement>} Promise that resolves to a canvas element
     */
    function takeScreenshot(viewer) {
        return html2canvas(viewer, {
            useCORS: true,              // Allow cross-origin resources
            allowTaint: true,           // Allow tainted canvases
            scrollX: 0,                 // Don't include horizontal scroll offset
            scrollY: 0,                 // Don't include vertical scroll offset
            width: viewer.clientWidth,  // Set canvas width to viewer width
            height: viewer.clientHeight, // Set canvas height to viewer height
            windowWidth: viewer.clientWidth,  // Set window width for rendering
            windowHeight: viewer.clientHeight, // Set window height for rendering
            scale: 1,                   // Use 1:1 scale for clarity
            logging: false              // Disable debug logging
        });
    }

    /**
     * Main function that handles the scrolling and PDF generation process
     * This is the core logic that:
     * 1. Finds the content viewer
     * 2. Calculates scroll positions and screenshot requirements
     * 3. Scrolls through content and captures screenshots
     * 4. Combines screenshots into a single PDF
     * 5. Downloads the resulting PDF
     */
    async function scrollAndCapturePDF() {
        // Step 1: Find the content viewer element
        const viewer = findContentViewer();
        if (!viewer) {
            alert('Content viewer not found! Please make sure you are on a page with scrollable content.');
            return;
        }

        // Step 2: Verify required libraries are loaded
        if (!window.html2canvas || !window.jspdf || !window.jspdf.jsPDF) {
            alert('Required libraries (html2canvas or jsPDF) failed to load. Please try again.');
            return;
        }

        console.log('Found viewer:', viewer);
        console.log('Viewer dimensions - Width:', viewer.clientWidth, 'Height:', viewer.clientHeight);
        console.log('Scroll dimensions - ScrollHeight:', viewer.scrollHeight, 'ScrollWidth:', viewer.scrollWidth);

        // Step 3: Calculate scrolling parameters
        const totalHeight = viewer.scrollHeight;    // Total scrollable height
        const viewportHeight = viewer.clientHeight; // Visible height of the viewer
        let currentScroll = 0;                      // Current scroll position
        const screenshots = [];                     // Array to store captured screenshots

        // Remember the original scroll position to restore later
        const originalScroll = viewer.scrollTop;

        // Step 4: Create progress indicator UI
        const progressDiv = document.createElement('div');
        progressDiv.style.position = 'fixed';
        progressDiv.style.top = '50%';
        progressDiv.style.left = '50%';
        progressDiv.style.transform = 'translate(-50%, -50%)';
        progressDiv.style.background = 'rgba(0,0,0,0.8)';
        progressDiv.style.color = 'white';
        progressDiv.style.padding = '20px';
        progressDiv.style.borderRadius = '10px';
        progressDiv.style.zIndex = '999999';
        progressDiv.style.fontSize = '16px';
        progressDiv.innerText = 'Capturing screenshots... 0%';
        document.body.appendChild(progressDiv);

        try {
            // Step 5: Calculate the number of screenshots needed
            let screenshotCount = 0;
            const totalScreenshots = Math.ceil(totalHeight / viewportHeight);

            console.log('Total screenshots needed:', totalScreenshots);
            console.log('Viewport height:', viewportHeight);
            console.log('Total height:', totalHeight);

            // Step 6: Handle non-scrollable content (single screenshot)
            if (totalHeight <= viewportHeight + 10) {
                console.log('Content is not scrollable, taking single screenshot');
                progressDiv.innerText = 'Capturing screenshot... 100%';
                const canvas = await takeScreenshot(viewer);
                screenshots.push(canvas);
            } else {
                // Step 7: MAIN SCROLLING AND CAPTURE LOOP
                // This is the core logic that scrolls through the content
                while (currentScroll < totalHeight) {
                    // Set the scroll position of the viewer
                    viewer.scrollTop = currentScroll;

                    // Update progress indicator
                    const progress = Math.round((screenshotCount / totalScreenshots) * 100);
                    progressDiv.innerText = `Capturing screenshots... ${progress}% (${screenshotCount + 1}/${totalScreenshots})`;

                    console.log('Taking screenshot at scroll position:', currentScroll);

                    // Wait for content to render after scrolling
                    // This delay is crucial for allowing:
                    // - Images to load
                    // - Text to render properly
                    // - CSS animations to complete
                    // - Dynamic content to update
                    await new Promise(resolve => setTimeout(resolve, 1200));

                    // Capture screenshot at current scroll position
                    const canvas = await takeScreenshot(viewer);
                    screenshots.push(canvas);
                    screenshotCount++;

                    // Check if we've reached the bottom of the content
                    // We use a 10px buffer to account for rounding errors
                    if (currentScroll + viewportHeight >= totalHeight - 10) {
                        console.log('Reached bottom of content');
                        break;
                    }

                    // Move to next scroll position
                    // We use 90% of viewport height to ensure some overlap between screenshots
                    // This overlap helps prevent content from being cut off between screenshots
                    currentScroll += viewportHeight * 0.9;
                }
            }

            // Step 8: Restore original scroll position
            viewer.scrollTop = originalScroll;
            progressDiv.innerText = `Generating PDF...`;

            // Step 9: Create PDF from captured screenshots
            const { jsPDF } = window.jspdf;

            // Calculate PDF dimensions based on viewer size
            // We use 0.75 scaling factor to convert pixels to points (PDF unit)
            const pdfWidth = viewer.clientWidth * 0.75;
            const pdfHeight = viewer.clientHeight * 0.75;

            // Create new PDF document
            const pdf = new jsPDF({
                orientation: "portrait",
                unit: "pt",                    // Use points as unit
                format: [pdfWidth, pdfHeight]  // Custom page size based on viewer
            });

            // Step 10: Add each screenshot as a page in the PDF
            for (let i = 0; i < screenshots.length; i++) {
                // Convert canvas to base64 PNG data
                const imgData = screenshots[i].toDataURL('image/png');

                // Add new page for each screenshot (except the first)
                if (i > 0) pdf.addPage();

                // Add image to PDF, scaling to fit the page
                pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
            }

            // Step 11: Generate filename from page content
            // Try multiple strategies to get a meaningful filename
            const sectionName = document.querySelector('.Sidebar_chapterTitle__mOVtZ.Sidebar_active__2relq')?.innerText
                || document.querySelector('.Sidebar_chapterTitle__mOVtZ')?.innerText
                || document.querySelector('[class*="chapter"][class*="active"]')?.innerText
                || document.querySelector('[class*="active"][class*="title"]')?.innerText
                || document.querySelector('h1')?.innerText
                || document.querySelector('h2')?.innerText
                || document.title
                || 'section';

            // Clean filename by removing special characters and replacing spaces with underscores
            const cleanSectionName = sectionName.replace(/[^\w\s-]/g, '').replace(/\s+/g, '_');

            // Step 12: Save the PDF
            pdf.save(`${cleanSectionName}.pdf`);

            // Step 13: Show success message and cleanup
            progressDiv.innerText = 'PDF generated successfully!';
            setTimeout(() => {
                document.body.removeChild(progressDiv);
                alert(`PDF downloaded successfully! Captured ${screenshots.length} pages.`);
            }, 1000);

        } catch (error) {
            // Step 14: Error handling
            console.error('Error generating PDF:', error);
            document.body.removeChild(progressDiv);
            alert(`Error generating PDF. Please try again.`);
        }
    }

    /**
     * Creates and adds the screenshot button to the page
     * The button is positioned fixed on the page and triggers the PDF generation process
     */
    function addButton() {
        // Remove existing button if it exists (prevents duplicates)
        const existingBtn = document.getElementById('screenshotCurrentSectionBtn');
        if (existingBtn) existingBtn.remove();

        // Create the button element
        const btn = document.createElement('button');
        btn.id = 'screenshotCurrentSectionBtn';
        btn.innerText = "Screenshot & PDF This Section";
        btn.setAttribute('aria-label', 'Capture section as PDF');

        // Apply comprehensive styling
        btn.style.cssText = `
            position: fixed;
            top: 100px;
            right: 20px;
            z-index: 99999;
            padding: 10px 18px;
            background: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        `;

        // Add hover effects
        btn.addEventListener('mouseover', () => {
            btn.style.background = '#c0392b';
            btn.style.transform = 'translateY(-2px)';
        });
        btn.addEventListener('mouseout', () => {
            btn.style.background = '#e74c3c';
            btn.style.transform = 'translateY(0)';
        });

        // Add click handler
        btn.addEventListener('click', () => {
            // Disable button during processing to prevent multiple clicks
            btn.disabled = true;
            btn.innerText = "Processing...";
            btn.style.background = "#95a5a6";

            // Load libraries and start the PDF generation process
            loadLibs(() => {
                scrollAndCapturePDF().finally(() => {
                    // Re-enable button after processing
                    btn.disabled = false;
                    btn.innerText = "Screenshot & PDF This Section";
                    btn.style.background = "#e74c3c";
                });
            });
        });

        // Add button to page
        document.body.appendChild(btn);
    }

    /**
     * Ensures the button exists on the page
     * This function is called periodically to handle dynamic page updates
     */
    function ensureButtonExists() {
        if (!document.getElementById('screenshotCurrentSectionBtn')) {
            addButton();
        }
    }

    // Initialize the script
    // Add button immediately if DOM is ready, otherwise wait for DOMContentLoaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', addButton);
    } else {
        addButton();
    }

    // Periodically check if button still exists (handles dynamic page updates)
    setInterval(ensureButtonExists, 5000);
})();